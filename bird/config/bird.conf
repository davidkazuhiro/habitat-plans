{{#if cfg.logs}}
# Configure logging
#log syslog { debug, trace, info, remote, warning, error, auth, fatal, bug };
#log stderr all;
#log "tmp" all;

{{/if~}}

{{#if cfg.router_id}}
# Override router ID
#router id 198.51.100.1;

{{/if~}}

{{#if cfg.custom_symbols}}
# You can define your own symbols...
#define xyzzy = (120+10);
#define '1a-a1' = (30+40);

{{/if~}}

{{#with cfg.router_filters}}
# Define a route filter...
filter {{name}} {
  {{#with filter}}
    {{#if condition}}
      if {{condition}} then {{consequent}};
      {{#if alternative}}
        else {{alternative}};
      {{/if}}
    {{#else}}
      {{consequent}};
    {{/if}}
  {{/with}}
}

{{/with ~}}

{{#if cfg.tables}}
# Define another routing table
#table testable;

{{/if ~}}

{{#if cfg.debug}}
# Turn on global debugging of all protocols
#debug protocols all;

{{/if ~}}

{{#if cfg.watchdog}}
# Turn on internal watchdog
#watchdog warning 5 s;
#watchdog timeout 30 s;

{{/if ~}}

{{#if cfg.direct}}
# The direct protocol automatically generates device routes to
# all network interfaces. Can exist in as many instances as you wish
# if you want to populate multiple routing tables with device routes.
protocol direct {
  interface
  {{~#with cfg.direct ~}}
    "{{interface}}"{{#unless @last}},{{/unless}}
  {{/with}};	# Restrict network interfaces it works with
}

{{/if ~}}

{{#with cfg.kernel}}
# This pseudo-protocol performs synchronization between BIRD's routing
# tables and the kernel. If your kernel supports multiple routing tables
# (as Linux 2.2.x does), you can run multiple instances of the kernel
# protocol and synchronize different kernel tables with different BIRD tables.
protocol kernel {
  {{#if learn}}learn;   # Learn all alien routes from the kernel{{/if}}
	{{#if persist}}persist;  # Don't remove routes on bird shutdown{{/if}}
  scan time {{scan_time}};  # Scan kernel routing table every {{scan_time}} seconds
  import {{import}};  # Default is import all
	export {{export}};  # Default is export none
  kernel table {{kernel_table}};  # Kernel table to synchronize with (default: main)
}

{{/with ~}}

{{#with cfg.device}}
# This pseudo-protocol watches all interface up/down events.
protocol device {
	scan time {{scan_time}};		# Scan interfaces every {{scan_time}} seconds
}

{{/with ~}}

{{#if cfg.static}}
# Static routes (again, there can be multiple instances, so that you
# can disable/enable various groups of static routes on the fly).
protocol static {
#	disabled;		# Disable by default
#	table testable;		# Connect to a non-default table
#	preference 1000;	# Default preference of routes
#	debug { states, routes, filters, interfaces, events, packets };
#	debug all;
#	route 0.0.0.0/0 via 198.51.100.13;
#	route 198.51.100.0/25 unreachable;
#	route 10.0.0.0/8 unreachable;
#	route 10.1.1.0:255.255.255.0 via 198.51.100.3;
#	route 10.1.2.0:255.255.255.0 via 198.51.100.3;
#	route 10.1.3.0:255.255.255.0 via 198.51.100.4;
#	route 10.2.0.0/24 via "arc0";
}

{{/if ~}}


{{#if cfg.pipe}}
# Pipe protocol connects two routing tables... Beware of loops.
#protocol pipe {
#	peer table testable;
# Define what routes do we export to this protocol / import from it.
#	import all;		# default is all
#	export all;		# default is none
#	import none;		# If you wish to disable imports
#	import filter test_filter;		# Use named filter
#	import where source = RTS_DEVICE;	# Use explicit filter
#}

{{/if ~}}

{{#if cfg.rip}}
# RIP aka Rest In Pieces...
#protocol rip MyRIP {	# You can also use an explicit name
#	preference xyzzy;
#	debug all;
#	port 1520;
#	period 7;
#	infinity 16;
#	garbage time 60;
#	interface "*" { mode broadcast; };
#	honor neighbor;		# To whom do we agree to send the routing table
#	honor always;
#	honor never;
#	passwords {
#		password "nazdar";
#	};
#	authentication none;
#	import filter { print "importing"; accept; };
#	export filter { print "exporting"; accept; };
#}

{{/if ~}}

{{#if cfg.ospf}}
#protocol ospf MyOSPF {
#       tick 2;
#	rfc1583compat yes;
#	area 0.0.0.0 {
#		stub no;
#		interface "eth*" {
#			hello 9;
#			retransmit 6;
#			cost 10;
#			transmit delay 5;
#			dead count 5;
#			wait 50;
#			type broadcast;
#			authentication simple;
#			password "pass";
#		};
#		interface "arc0" {
#			rx buffer large;
#			type nonbroadcast;
#			poll 14;
#			dead 75;
#			neighbors {
#				10.1.1.2 eligible;
#				10.1.1.4;
#			};
#			strict nonbroadcast yes;
#		};
#		interface "xxx0" {
#                       passwords {
#				password "abc" {
#					id 1;
#					generate to "22-04-2003 11:00:06";
#					accept to "17-01-2004 12:01:05";
#				};
#				password "def" {
#					id 2;
#					generate from "22-04-2003 11:00:07";
#					accept from "17-01-2003 12:01:05";
#				};
#			};
#                       authentication cryptographic;
#		};
#	};
#	area 20 {
#		stub 1;
#		interface "ppp1" {
#			hello 8;
#			authentication none;
#		};
#               interface "fr*";
#               virtual link 192.168.0.1 {
#                       password "sdsdffsdfg";
#                       authentication cryptographic;
#               };
#	};
#}

{{/if ~}}

{{#with cfg.bgp_template}}
template bgp {{name}} {
  {{#if disabled}}disabled;{{/if}}
  local as {{local_asn}};
  {{#if multihop}}multihop;{{/if}}
  {{#if rr_client}}rr client;{{/if}}
  {{#if rr_cluster_id ~}}
    rr cluster id {{rr_cluster_id}};
  {{/if}}
}

{{/with ~}}

{{#with cfg.bgp}}
protocol bgp {{#if cfg.bgp_template}}from {{cfg.bgp_template.name}}{{/if}}{
  {{#if disabled}}disabled;{{/if}}
  description "{{description}}";
  local as {{local_asn}};
  neighbor {{neighbor_address}} as {{neighbor_asn}};
  {{#if multihop}}multihop;{{/if}}
  hold time {{hold_time}};
  startup hold time {{startup_hold_time}};
  connect retry time {{connect_retry_time}};
  keepalive time {{keepalive_time}};  # defaults to hold time / 3
  start delay time {{start_delay_time}};   # How long do we wait before initial connect
  error wait time {{error_wait_time_min}}, {{error_wait_time_max}};# Minimum and maximum time we wait after an error (when consecutive
#				# errors occur, we increase the delay exponentially ...
  error forget time {{error_forget_time}}; # ... until this timeout expires)
  {{#if disable_after_error}}disable after error;  # Disable the protocol automatically when an error occurs{{/if}}
  {{#if next_hop_self}}next hop self;  # Disable next hop processing and always advertise our local address as nexthop{{/if}}
  path metric {{path_metric}};  # Prefer routes with shorter paths (like Cisco does)
  default bgp_med {{bgp_med}}; # MED value we use for comparison when none is defined
  default bgp_local_pref {{bgp_local_pref}};	# The same for local preference
  source address {{source_address}}; # What local address we use for the TCP connection
  password "{{password}}";	# Password used for MD5 authentication
  {{#if rr_client ~}}
    rr client;  # I am a route reflector and the neighbor is my client
  {{/if}}
  {{#if rr_cluster_id ~}}
    rr cluster id {{rr_cluster_id}};	# Use this value for cluster id instead of my router id
  {{~/if}}
  export where source={{export_where_source}};
  {{#if export_filter ~}}
    export filter {{export_filter}};
  {{/if}}
}
{{~/with}}
